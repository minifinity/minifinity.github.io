<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Writing</title>
	<subtitle>Cool stuff I thought about</subtitle>
	<link href="https://minifinity.github.io/writing/feed.xml" rel="self" type="application/atom+xml"/>
    <link href="https://minifinity.github.io/writing/"/>
	<updated>2025-06-18T00:00:00+00:00</updated>
	<id>https://minifinity.github.io/writing/feed.xml</id>
	<entry xml:lang="en">
		<title>Out Of Step In Stanford Time</title>
		<published>2025-06-18T00:00:00+00:00</published>
		<updated>2025-06-18T00:00:00+00:00</updated>
		<link href="https://minifinity.github.io/writing/stanford-time/" type="text/html"/>
		<id>https://minifinity.github.io/writing/stanford-time/</id>
		<content type="html">&lt;p&gt;I know the exact moment I realized that I had lost touch with time. Or more specifically, that I had lost touch with leisure. It was when my bike was stolen. I&#x27;d left it unlocked in front of a dining hall while I grabbed dinner, and when I came back for it, it was gone.&lt;&#x2F;p&gt;
&lt;p&gt;Up until that point in the year — that is, a short month before summer — my feet probably hit bike pedals more often than the sidewalk. I&#x27;m not the greatest cyclist, and I&#x27;m particularly terrible at the many roundabouts on campus, but I can spin myself to class in 8 minutes if I &lt;em&gt;had&lt;&#x2F;em&gt; to.&lt;&#x2F;p&gt;
&lt;p&gt;Since the campus is 8,000 acres, and my schedule was planned down to 15-minute blocks, and I had a day with a 7:30am appointment in a neighboring city followed by three exams in the next 24 hours, I found myself &lt;em&gt;having to&lt;&#x2F;em&gt; very often. Then even when I did have ample time, I still &lt;em&gt;had to&lt;&#x2F;em&gt;, because I wanted to sleep in a little longer, and my legs deserved a break, and I just didn&#x27;t want to walk, and my stomach hurt from too much ice cream, and anyway everyone else is biking.&lt;&#x2F;p&gt;
&lt;p&gt;So I had something of a crisis when those pedals were gone.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;My kindergarten teacher wrote in my report card:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;[Zara&#x27;s] penmanship and art work are exceptional [...] She sets high standards for herself and always aims for perfection when drawing her illustrations or printing. Although this is admirable, it prevents her from completing her work. I would like her to focus on working more quickly and finishing tasks within the allotted time frame.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;What she was referring to was my huge stack of half-finished Weekend Journals, where us kids doodle and caption an event from our latest weekend, every week. In my journal, the typical entry looked like a perfectly straight sideview of me at my piano with one section perfectly colored within the lines, surrounded by no color anywhere else and two hurriedly scribbled words.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s a real problem. Since having me, I think my poor mother has consistently been one &quot;five more minutes!&quot; away from losing it. Unlike her, I&#x27;m severely time blind — I process time less like an ever-diminishing resource and more a continuous contextless soup of whatever experiences happened to feed it. Taking less or more than &quot;enough&quot; time, &quot;using&quot; time wisely, or (heaven forbid) &quot;wasting&quot; time never occurs to me naturally. I am simply in time, and time is in me. There is no separate entity, so there is nothing to measure, use, or waste.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;It&#x27;s also the reason I didn&#x27;t know what to do with myself after I arrived at Stanford.&lt;&#x2F;p&gt;
&lt;p&gt;1,700 wide-eyed freshmen from all over the world hit the ground running. We have the next four years to realize our wildest dreams. Some are looking for freedom and independence. Others better futures for their family. Still others the next big idea and their co-founders.&lt;&#x2F;p&gt;
&lt;p&gt;What are we to do?&lt;&#x2F;p&gt;
&lt;p&gt;Where do we start? Who do we meet? How do we make it? When will we know that we have made it, whatever it is?&lt;&#x2F;p&gt;
&lt;p&gt;Or even worse, what if we let the sand slip through our fingers? What if we &lt;em&gt;don&#x27;t&lt;&#x2F;em&gt; make the most out of this purported golden ticket? Will it expire? How is this thought infinitely more torturous than the last?&lt;&#x2F;p&gt;
&lt;p&gt;I run around shaking hands. &lt;em&gt;Hello, hello! Yes, the grass is green, the sky is blue, and it&#x27;s so hot out. Here&#x27;s my elevator pitch. And my LinkedIn.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;I felt like I was drinking time. It manifested physically.&lt;&#x2F;p&gt;
&lt;p&gt;I couldn&#x27;t walk fast enough. If biking was email, then walking was messages by pigeon. &lt;em&gt;How to optimize caveman ways?&lt;&#x2F;em&gt; I found out that I walk 120 beats per minute, with each step falling 0.8 sidewalk concrete tiles apart, so that every five steps or so I would land on a crack.&lt;&#x2F;p&gt;
&lt;p&gt;I realized that coffee made my lips loose and mind jittery, but I was on a daily basis with the dining hall coffee machine, and a twice-daily basis with café quesadillas.&lt;&#x2F;p&gt;
&lt;p&gt;I couldn&#x27;t sleep. Eyelids heavy, slumber a feather. Something was always tomorrow. The alarm is set for 6:00am. &lt;em&gt;Have I overslept?&lt;&#x2F;em&gt; I open my eyes — it&#x27;s 5:37am. Again — it&#x27;s 5:49. Then 5:53. Then 5:55. 5:56. At 5:57, I preemptively switch off the alarm and fall into the new day.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Turns out, my bike wasn&#x27;t stolen. More specifically, it was on the closest bike rack directly in front of my usual dorm exit. I was watching my friend move his bike as he was packing up for the summer, and when I turned around, it was there.&lt;&#x2F;p&gt;
&lt;p&gt;The short month was over. My pedals were lightly laced with cobwebs, but I&#x27;d worn out a pair of shoes. I&#x27;m still not the greatest pedestrian, and I&#x27;m particularly terrible at not tripping over every uneven sidewalk crack on campus, but I can churn myself 10,000 steps a day if I &lt;em&gt;had&lt;&#x2F;em&gt; to.&lt;&#x2F;p&gt;
&lt;p&gt;Since the campus is 8,000 acres, and my schedule was planned down to 15-minute blocks, and I had another day with two classes, a 15-page essay due, and final exams looming overhead, I found myself &lt;em&gt;having to&lt;&#x2F;em&gt; very often. Then even when I did have ample time, I still had to, because I wanted to enjoy the morning a little slower, and my brain deserved a break, and I just didn&#x27;t want to crash at another roundabout, and my stomach hurt from too much ice cream, and anyway, I wanted my feet in time with the sidewalk cracks.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Graphs, Git, and Havel-Hakimi</title>
		<published>2025-06-17T00:00:00+00:00</published>
		<updated>2025-06-17T00:00:00+00:00</updated>
		<link href="https://minifinity.github.io/writing/havel-hakimi/" type="text/html"/>
		<id>https://minifinity.github.io/writing/havel-hakimi/</id>
		<content type="html">&lt;h2 id=&quot;havel-hakimi&quot;&gt;Havel-Hakimi&lt;a class=&quot;zola-anchor&quot; href=&quot;#havel-hakimi&quot; aria-label=&quot;Anchor link for: havel-hakimi&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;re given a degree sequence — that is, the degrees of a set of nodes — and we want to build a graph out of it. How do we do that?&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Havel%E2%80%93Hakimi_algorithm&quot;&gt;Havel-Hakimi algorithm&lt;&#x2F;a&gt; gives a way to construct a &lt;em&gt;simple graph&lt;&#x2F;em&gt; from the degree sequence if one exists.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Say we are given the degree sequence &lt;code&gt;[3, 2, 3, 1, 1]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Find the highest degree $d$ in the sequence (in this case, $3$), and remove it or zero it out -&amp;gt; &lt;code&gt;[0, 2, 3, 1, 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Subtract $1$ from the next $d$ largest degrees in the remaining list. This is akin to &quot;satisfying&quot; the largest degree by connecting each of its allotted edges to other nodes with the most remaining degree requirements -&amp;gt; &lt;code&gt;[0, 1, 2, 0, 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Repeat until either:
&lt;ul&gt;
&lt;li&gt;One gets all zeros, indicating that a graph exists for that degree sequence. This is the case here:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[0, 1, 2, 0, 1]&lt;&#x2F;code&gt; continuing from step 2 -&amp;gt; &lt;code&gt;[0, 1, 0, 0, 1]&lt;&#x2F;code&gt; zeroing out the highest degree -&amp;gt; &lt;code&gt;[0, 0, 0, 0, 0]&lt;&#x2F;code&gt; &quot;satisfying&quot; the largest degree&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;One gets a negative number, or there are not enough numbers to subtract from, indicating that the degree sequence is not graphical&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;naive-approach&quot;&gt;Naïve Approach&lt;a class=&quot;zola-anchor&quot; href=&quot;#naive-approach&quot; aria-label=&quot;Anchor link for: naive-approach&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;I was told that the best way to learn is to &lt;em&gt;first&lt;&#x2F;em&gt; code up the most straightforward version of a program, and &lt;em&gt;then&lt;&#x2F;em&gt; sequentially improving upon it. So I did just that. A naïve Havel-Hakimi might look something like this:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;while True:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    max = find max(sequence)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    sequence[max index] = 0
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    if (max &amp;gt; len(sequence)):          return False    # not enough nodes
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    if (any elements in sequence &amp;lt; 0): return False    # negative degrees
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    if (all elements in sequence = 0): return True     # we&amp;#39;re done
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    for i in range(max):
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        next largest deg = find max(sequence)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        next largest deg -= 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s a surprisingly simple algorithm. But there is one issue: &lt;strong&gt;time complexity.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For a worst-case analysis of the time complexity, assume that the degree sequence is graphical (this means the program will not return &lt;code&gt;False&lt;&#x2F;code&gt; &quot;early&quot;). Let $N$ be the number of nodes and $E$ the number of edges in the resulting graph. We have that $N$ is the length of our list, and $E$ the sum of our list divided by two (as each edge contributes to two degrees).&lt;&#x2F;p&gt;
&lt;p&gt;This double loop ...&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;while True:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    for i in range(max):
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        next largest deg = find max(sequence)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;... is the main bottle neck of this implementation. Conceptually, each iteration of the inner loop creates an edge, and the outer loop runs until all possible edges are created, so &lt;strong&gt;the total number of iterations is exactly $E$.&lt;&#x2F;strong&gt; Then, within each iteration, &lt;code&gt;find max(sequence)&lt;&#x2F;code&gt; must loop through the degrees of all nodes, and is thus an $\mathcal{O}(N)$ operation. Together, that makes an $\mathcal{O}(N\cdot E)$ implementation, which is slow for large graphs.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that in simple graphs, we have $E \leq \frac{N(N-1)}{2}$. Thus, in the true worst case, we obtain a time complexity of $\mathcal{O}(N\cdot \frac{N(N-1)}{2})$ or $\mathcal{O}(N^3)$ (slow!)&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;slightly-better&quot;&gt;Slightly Better&lt;a class=&quot;zola-anchor&quot; href=&quot;#slightly-better&quot; aria-label=&quot;Anchor link for: slightly-better&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;while True:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    sort(sequence)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    max = sequence[0] 
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    sequence[0] = 0                             # set highest degree to 0
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    if (max &amp;gt; len(sequence)):          return False    # not enough nodes
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    if (any elements in sequence &amp;lt; 0): return False    # negative degrees
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    if (all elements in sequence = 0): return True 
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    for i in range(max):
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        degree seq[i+1] -= 1                       # next d largest degrees
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Node to Joy</title>
		<published>2025-05-10T00:00:00+00:00</published>
		<updated>2025-05-10T00:00:00+00:00</updated>
		<link href="https://minifinity.github.io/writing/node-to-joy/" type="text/html"/>
		<id>https://minifinity.github.io/writing/node-to-joy/</id>
		<content type="html">&lt;p&gt;This summer, I&#x27;ll be working with the &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;igraph.org&#x2F;&quot;&gt;igraph&lt;&#x2F;a&gt; team on their open-source network analysis library through &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;summerofcode.withgoogle.com&#x2F;&quot;&gt;Google Summer of Code&lt;&#x2F;a&gt;. I&#x27;m thrilled for the opportunity to learn from two dedicated mentors and to dive into a topic I&#x27;ve been fascinated by: network science and graph theory.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;project&quot;&gt;Project&lt;a class=&quot;zola-anchor&quot; href=&quot;#project&quot; aria-label=&quot;Anchor link for: project&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;The objective is to expand on igraph’s current functionality to more flexibly work with &lt;strong&gt;degree-constrained null models&lt;&#x2F;strong&gt;. &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Null_model&quot;&gt;Null models&lt;&#x2F;a&gt; are useful because they provide a baseline for determining whether graphs of interest display “non-trivial features” – in other words, they offer a way to define a &quot;generic&quot; or &quot;random&quot; graph so observed features in network of interest can be compared against a meaningful reference point.&lt;&#x2F;p&gt;
&lt;p&gt;When constructing such a null model, it&#x27;s important to preserve certain properties of the original graph so that comparisons remain relevant. One potential preserved property is the &lt;strong&gt;degree sequence&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;degree sequence&lt;&#x2F;strong&gt; is a list of the number of edges connected to each node in a graph. For example, if a graph has six nodes and they each have 1, 3, 3, 2, 2, and 2 edges connected to them, then the &lt;em&gt;degree sequence&lt;&#x2F;em&gt; is [1, 3, 3, 2, 2, 2]. This captures the distribution of &quot;connectedness&quot; across the graph.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Preserving the degree sequence ensures that the null model retains the same distribution of connectivity, making a comparison more meaningful.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;details&quot;&gt;Details&lt;a class=&quot;zola-anchor&quot; href=&quot;#details&quot; aria-label=&quot;Anchor link for: details&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;Three functionalities will be extended to work with more graph structures:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Graphicality: can a graph be built from this degree sequence?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The first step in working with a degree-constrained null model is checking whether a graph &lt;em&gt;can&lt;&#x2F;em&gt; be constructed from a given degree sequence, or checking for &quot;graphicality.&quot;&lt;&#x2F;p&gt;
&lt;p&gt;igraph already includes &lt;code&gt;is_graphical()&lt;&#x2F;code&gt; and &lt;code&gt;is_bigraphical()&lt;&#x2F;code&gt; functions that support various combinations of edge types (like loops or multi-edges), both directed and undirected graphs, and bipartite graphs. However, there&#x27;s currently no efficient way to check graphicality for connected graphs. This can be extended from &lt;code&gt;is_potentially_connected()&lt;&#x2F;code&gt;, ideally in linear time.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Construction: building a graph that matches a degree sequence&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Once we know a graph is possible, the next step is to actually build one.&lt;&#x2F;p&gt;
&lt;p&gt;igraph’s &lt;code&gt;realize_degree_sequence()&lt;&#x2F;code&gt; can already generate graphs across different types (simple, multigraphs, with or without loops), and it has a companion for bipartite graphs. This project will build on that foundation in two ways:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Adding support for graphs with loops but no multi-edges (a currently missing case)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Implementing improved methods for construction algorithms&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rewiring: randomizing edges while preserving a degree sequence&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The final step is to generate random graphs that still match the degree sequence of the original.&lt;&#x2F;p&gt;
&lt;p&gt;igraph’s current &lt;code&gt;rewire()&lt;&#x2F;code&gt; function handles a limited set of graph types and can’t reach all possible graphs with the same in- and out-degree sequences. The plan is to:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Add support for more combinations of edge types&lt;&#x2F;li&gt;
&lt;li&gt;Support rewiring for bipartite graphs while preserving partitions&lt;&#x2F;li&gt;
&lt;li&gt;Enable a three-edge swap method for directed graphs to ensure all valid graphs can be reached with equal probability&lt;&#x2F;li&gt;
&lt;li&gt;Add flexibility to preserve only in-degree or only out-degree, depending on use case&lt;&#x2F;li&gt;
&lt;li&gt;Make it possible to rewire graphs while preserving connectivity, using a more efficient Viger–Latapy method&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;At its core, null models help researchers ask better questions about networks – not just &lt;em&gt;what&lt;&#x2F;em&gt; it looks like, but &lt;em&gt;why&lt;&#x2F;em&gt; it looks that way, and whether that is meaningful or expected. By improving how igraph handles degree-constrained null models, I hope to make a small but practical contribution to network science.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Much of this work was informed by a paper by one of my mentors, Szabolcs Horvát, and Carl D Modes: &lt;em&gt;“Connectedness matters: construction and exact random sampling of connected
networks.”&lt;&#x2F;em&gt; (DOI: 10.1088&#x2F;2632-072X&#x2F;abced5).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;more-thoughts&quot;&gt;More Thoughts&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-thoughts&quot; aria-label=&quot;Anchor link for: more-thoughts&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;I can&#x27;t recall how or why I became interested in networks and graphs. My hypothesis is that it stemmed from the abundance of time I had to traverse Wikipedia rabbit holes during the COVID pandemic.&lt;&#x2F;p&gt;
&lt;p&gt;Often, I&#x27;d start on a page that wasn&#x27;t exactly what I was looking for – maybe the term was too broad or too narrow, or only tangentially related. But unless you were on a page with less than a handful of links, you would eventually find a link to something that felt like it pointed in the right direction, or at least was the closest of the available links to the right direction.&lt;&#x2F;p&gt;
&lt;p&gt;Maybe I was drawn to the idea that we carry around a kind of &quot;semantic distance&quot; in our heads – a fuzzy intuition for how ideas are related, even if we can&#x27;t express it precisely. Maybe I just wanted to beat all my friends at the &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;wikispeedrun.org&#x2F;&quot;&gt;Wikipedia speedrun&lt;&#x2F;a&gt;, a shortest-path problem in disguise. Or maybe it all started when I came across &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;-llumS2rA8I?si=choIrC7Ch_6IObbN&quot;&gt;the most aesthetically-arresting graph theoretic analysis&lt;&#x2F;a&gt; explaining &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wikipedia:Getting_to_Philosophy&quot;&gt;why most Wikipedia pages eventually link back to &quot;Philosophy,&quot;&lt;&#x2F;a&gt; and I was just drunk on the visuals.&lt;&#x2F;p&gt;
&lt;p&gt;In any case, I began my undergraduate study in computer science largely owing to this interest in graphs, networks, and structural abstractions which, while not the most conventional starting point, drew me into computer science and discrete mathematics in an organic way. There is no shortage of nodes and edges in everyday life. Social media connections link people. Highways systems weave cities. Neurons wire our own thoughts and consciousness.&lt;&#x2F;p&gt;
&lt;p&gt;Formalities aside, the idea behind networks – that the relationships between things are just as interesting as the things themselves – is one that seemingly underpins both social and natural worlds. The more I learn about them, the more I am awed by their ability to model complexities with such minimal ingredients.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>